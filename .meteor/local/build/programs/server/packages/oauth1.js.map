{"version":3,"file":"/packages/oauth1.js","sources":["oauth1/oauth1_binding.js","oauth1/oauth1_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,mC;AACA,6C;;AAEA,iE;AACA,6B;AACA,E;AACA,yB;AACA,+C;AACA,6C;AACA,uB;AACA,iC;AACA,8B;AACA,gC;AACA,iC;AACA,wC;AACA,wB;AACA,oB;AACA,E;;AAEA,qE;AACA,kB;;AAEA,mC;AACA,+B;AACA,K;;AAEA,sE;AACA,mD;;AAEA,uC;AACA,oB;AACA,6E;;AAEA,yC;AACA,sD;AACA,E;;AAEA,kF;AACA,kB;;AAEA,oE;AACA,wB;AACA,I;AACA,qE;AACA,mE;AACA,mC;AACA,yB;AACA,gD;;AAEA,mC;AACA,mC;AACA,wC;AACA,K;;AAEA,qE;AACA,mD;;AAEA,wC;AACA,qD;AACA,E;;AAEA,wE;AACA,kB;;AAEA,mC;AACA,iC;AACA,K;;AAEA,e;AACA,gB;AACA,G;;AAEA,4D;AACA,E;;AAEA,+D;AACA,iD;AACA,E;;AAEA,gE;AACA,kD;AACA,E;;AAEA,0D;AACA,kB;AACA,mB;AACA,iD;AACA,gD;AACA,wC;AACA,sE;AACA,wB;AACA,c;AACA,E;;AAEA,sG;AACA,kB;AACA,iE;;AAEA,sD;AACA,2B;AACA,sB;;AAEA,uB;AACA,W;AACA,4B;AACA,kC;AACA,c;;AAEA,iE;AACA,wB;AACA,wD;;AAEA,sF;AACA,E;;AAEA,kF;AACA,kB;;AAEA,iE;AACA,iC;AACA,oB;AACA,G;;AAEA,sB;AACA,2B;AACA,6E;;AAEA,yD;AACA,sD;;AAEA,wB;AACA,O;AACA,mC;AACA,qB;AACA,gB;AACA,iC;AACA,O;AACA,iB;AACA,iB;AACA,6F;AACA,6C;AACA,G;AACA,E;;AAEA,0D;AACA,kB;AACA,oD;AACA,4D;AACA,gB;AACA,S;AACA,E;;AAEA,uD;AACA,kF;AACA,E;;AAEA,kE;AACA,kB;AACA,wD;AACA,0E;AACA,uB;AACA,E;;;;;;;;;;;;;;;;;;;ACjKA,uD;AACA,uB;;AAEA,4C;;AAEA,qB;AACA,8D;;AAEA,2F;AACA,gB;AACA,qG;AACA,G;;AAEA,0B;AACA,qD;;AAEA,sC;AACA,6C;;AAEA,gD;AACA,oE;;AAEA,uE;AACA,kC;AACA,+C;AACA,yD;AACA,M;;AAEA,wC;AACA,gC;AACA,iD;AACA,oD;AACA,Y;AACA,oF;AACA,K;;AAEA,6E;AACA,kD;AACA,c;AACA,U;AACA,kE;AACA,iE;AACA,uD;;AAEA,oE;AACA,+D;AACA,2E;AACA,sC;;AAEA,gE;AACA,0C;AACA,kE;;AAEA,kE;AACA,iE;;AAEA,kD;AACA,iE;;AAEA,sC;AACA,iE;;AAEA,+C;AACA,2D;AACA,yC;AACA,6C;AACA,oC;AACA,Q;AACA,K;;AAEA,2D;AACA,wB;AACA,0C;AACA,G;AACA,E","sourcesContent":["var crypto = Npm.require(\"crypto\");\nvar querystring = Npm.require(\"querystring\");\n\n// An OAuth1 wrapper around http calls which helps get tokens and\n// takes care of HTTP headers\n//\n// @param config {Object}\n//   - consumerKey (String): oauth consumer key\n//   - secret (String): oauth consumer secret\n// @param urls {Object}\n//   - requestToken (String): url\n//   - authorize (String): url\n//   - accessToken (String): url\n//   - authenticate (String): url\nOAuth1Binding = function(config, urls) {\n  this._config = config;\n  this._urls = urls;\n};\n\nOAuth1Binding.prototype.prepareRequestToken = function(callbackUrl) {\n  var self = this;\n\n  var headers = self._buildHeader({\n    oauth_callback: callbackUrl\n  });\n\n  var response = self._call('POST', self._urls.requestToken, headers);\n  var tokens = querystring.parse(response.content);\n\n  if (!tokens.oauth_callback_confirmed)\n    throw new Error(\n      \"oauth_callback_confirmed false when requesting oauth1 token\", tokens);\n\n  self.requestToken = tokens.oauth_token;\n  self.requestTokenSecret = tokens.oauth_token_secret;\n};\n\nOAuth1Binding.prototype.prepareAccessToken = function(query, requestTokenSecret) {\n  var self = this;\n\n  // support implementations that use request token secrets. This is\n  // read by self._call.\n  //\n  // XXX make it a param to call, not something stashed on self? It's\n  // kinda confusing right now, everything except this is passed as\n  // arguments, but this is stored.\n  if (requestTokenSecret)\n    self.accessTokenSecret = requestTokenSecret;\n\n  var headers = self._buildHeader({\n    oauth_token: query.oauth_token,\n    oauth_verifier: query.oauth_verifier\n  });\n\n  var response = self._call('POST', self._urls.accessToken, headers);\n  var tokens = querystring.parse(response.content);\n\n  self.accessToken = tokens.oauth_token;\n  self.accessTokenSecret = tokens.oauth_token_secret;\n};\n\nOAuth1Binding.prototype.call = function(method, url, params, callback) {\n  var self = this;\n\n  var headers = self._buildHeader({\n    oauth_token: self.accessToken\n  });\n\n  if(!params) {\n    params = {};\n  }\n\n  return self._call(method, url, headers, params, callback);\n};\n\nOAuth1Binding.prototype.get = function(url, params, callback) {\n  return this.call('GET', url, params, callback);\n};\n\nOAuth1Binding.prototype.post = function(url, params, callback) {\n  return this.call('POST', url, params, callback);\n};\n\nOAuth1Binding.prototype._buildHeader = function(headers) {\n  var self = this;\n  return _.extend({\n    oauth_consumer_key: self._config.consumerKey,\n    oauth_nonce: Random.id().replace(/\\W/g, ''),\n    oauth_signature_method: 'HMAC-SHA1',\n    oauth_timestamp: (new Date().valueOf()/1000).toFixed().toString(),\n    oauth_version: '1.0'\n  }, headers);\n};\n\nOAuth1Binding.prototype._getSignature = function(method, url, rawHeaders, accessTokenSecret, params) {\n  var self = this;\n  var headers = self._encodeHeader(_.extend(rawHeaders, params));\n\n  var parameters = _.map(headers, function(val, key) {\n    return key + '=' + val;\n  }).sort().join('&');\n\n  var signatureBase = [\n    method,\n    self._encodeString(url),\n    self._encodeString(parameters)\n  ].join('&');\n\n  var signingKey = self._encodeString(self._config.secret) + '&';\n  if (accessTokenSecret)\n    signingKey += self._encodeString(accessTokenSecret);\n\n  return crypto.createHmac('SHA1', signingKey).update(signatureBase).digest('base64');\n};\n\nOAuth1Binding.prototype._call = function(method, url, headers, params, callback) {\n  var self = this;\n\n  // all URLs to be functions to support parameters/customization\n  if(typeof url === \"function\") {\n    url = url(self);\n  }\n\n  // Get the signature\n  headers.oauth_signature =\n    self._getSignature(method, url, headers, self.accessTokenSecret, params);\n\n  // Make a authorization string according to oauth1 spec\n  var authString = self._getAuthHeaderString(headers);\n\n  // Make signed request\n  try {\n    return HTTP.call(method, url, {\n      params: params,\n      headers: {\n        Authorization: authString\n      }\n    }, callback);\n  } catch (err) {\n    throw _.extend(new Error(\"Failed to send OAuth1 request to \" + url + \". \" + err.message),\n                   {response: err.response});\n  }\n};\n\nOAuth1Binding.prototype._encodeHeader = function(header) {\n  var self = this;\n  return _.reduce(header, function(memo, val, key) {\n    memo[self._encodeString(key)] = self._encodeString(val);\n    return memo;\n  }, {});\n};\n\nOAuth1Binding.prototype._encodeString = function(str) {\n  return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n};\n\nOAuth1Binding.prototype._getAuthHeaderString = function(headers) {\n  var self = this;\n  return 'OAuth ' +  _.map(headers, function(val, key) {\n    return self._encodeString(key) + '=\"' + self._encodeString(val) + '\"';\n  }).sort().join(', ');\n};\n","// A place to store request tokens pending verification\nvar requestTokens = {};\n\nOAuth1Test = {requestTokens: requestTokens};\n\n// connect middleware\nOauth._requestHandlers['1'] = function (service, query, res) {\n\n  var config = ServiceConfiguration.configurations.findOne({service: service.serviceName});\n  if (!config) {\n    throw new ServiceConfiguration.ConfigError(\"Service \" + service.serviceName + \" not configured\");\n  }\n\n  var urls = service.urls;\n  var oauthBinding = new OAuth1Binding(config, urls);\n\n  if (query.requestTokenAndRedirect) {\n    // step 1 - get and store a request token\n\n    // Get a request token to start auth process\n    oauthBinding.prepareRequestToken(query.requestTokenAndRedirect);\n\n    // Keep track of request token so we can verify it on the next step\n    requestTokens[query.state] = {\n      requestToken: oauthBinding.requestToken, \n      requestTokenSecret: oauthBinding.requestTokenSecret\n    };\n\n    // support for scope/name parameters\n    var redirectUrl = undefined;\n    if(typeof urls.authenticate === \"function\") {\n      redirectUrl = urls.authenticate(oauthBinding);\n    } else {\n      redirectUrl = urls.authenticate + '?oauth_token=' + oauthBinding.requestToken;\n    }\n\n    // redirect to provider login, which will redirect back to \"step 2\" below\n    res.writeHead(302, {'Location': redirectUrl});\n    res.end();\n  } else {\n    // step 2, redirected from provider login - complete the login\n    // process: if the user authorized permissions, get an access\n    // token and access token secret and log in as user\n\n    // Get the user's request token so we can verify it and clear it\n    var requestToken = requestTokens[query.state].requestToken;\n    var requestTokenSecret = requestTokens[query.state].requestTokenSecret;\n    delete requestTokens[query.state];\n\n    // Verify user authorized access and the oauth_token matches\n    // the requestToken from previous step\n    if (query.oauth_token && query.oauth_token === requestToken) {\n\n      // Prepare the login results before returning.  This way the\n      // subsequent call to the `login` method will be immediate.\n\n      // Get the access token for signing requests\n      oauthBinding.prepareAccessToken(query, requestTokenSecret);\n\n      // Run service-specific handler.\n      var oauthResult = service.handleOauthRequest(oauthBinding);\n\n      // Add the login result to the result map\n      Oauth._loginResultForCredentialToken[query.state] = {\n        serviceName: service.serviceName,\n        serviceData: oauthResult.serviceData,\n        options: oauthResult.options\n      };\n    }\n\n    // Either close the window, redirect, or render nothing\n    // if all else fails\n    Oauth._renderOauthResults(res, query);\n  }\n};\n"]}